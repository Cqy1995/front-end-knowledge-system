## CSS😏

### css 基础

#### 优先级规则

优先级由高到低：

1. !important
2. 匹配优先级计算，详情见下文
3. 若以上规则都无法解决，后来者优先级高
4. user agent stylesheet

优先级计算：A:内联样式 B:id 选择器 C:类选择器/属性选择器/伪类 D：标签选择器/伪元素  
⚠️ 少使用!important 尤其是在 npm 这种。伪类是单:，伪元素是双::  
user agent stylesheet 是浏览器默认的样式，不同浏览器不通

#### 盒模型

标准模式下，box-sizing 的值为 content-box，当给一个盒子设置宽高后，实际是给 content 设置宽高，所有的 padding、border 再往外扩展  
IE 下：box-sizing 的值为 border-box,当给一个盒子设置宽高后，指定的宽高是包含 border 和 padding

#### 格式化上下文

#### 块级格式化上下文 BFC

1. 垂直方向依次排列。
2. 上下的间距由 margin，同一 BFC 的子盒子会重叠。
3. BFC 里面的内容不会影响外部，反之也是。
4. 每个元素与 bfc 内容左侧相邻，float 也是。
5. BFC 不会与 float 重叠。
6. 计算高度 float 也会计算在内。

#### 行内格式化上下文 IFC

1. 水平方向依次排列。
2. 超出后换行。
3. 计算高度以子元素最大高度为准。

#### margin

对于行内替换元素来说，4 个方向的 margin 都是起作用的  
对于行内非替换元素来说，只有 margin-left 和 margin-right 起作用，margin-top 和 margin-bottom 是不起作用的

#### vertical-align 在 display:inline 与 table-cell 起作用。

#### 元素垂直居中

在项目中是很常见的
最开始我使用
1. 把容器的 line-height 属性设置为和容器的高度一样，但只有单行文字有效果。  
2. 如果知道容器和元素的高度，用绝对定位；  
3. 如果不知道元素的高度时，结合定位和 transform 一起用。  
后来使用css3，尤其是移动端时候特别强大，   
4. 可以用 flexbox 的话，就使用 flexbox；
看博客或文章也有了解到    
5. 当不需要指定元素的高度时，可以直接给一个相同的 padding-top 和 padding-bottom，让元素和 padding 一起撑起来容器；  
6. 需要指定容器高度，或者不能使用 padding 的时候，设置元素 display: table-cell 和 vertical-align: middle；  
  

### CSS 层叠上下文

HTML 元素层级是所谓的文档流,CSS 层叠上下文是文档流的子层叠。  
一个页面中可能会有很多个层叠上下文，而层叠上下文之间是独立的。层叠上下文里有一套自己的排列规则

#### 层叠上下文之间如何排列?

1.对于未定位元素，按照在元素在 HTML 文档中出现的顺序决定，越后面的元素越会覆盖在上面  
2.先渲染未定位元素，再渲染定位元素  
**_当一个元素被设置 z-index，它的所有后代和本元素形成一个层叠栈，也就是层叠上下文_**
_层叠上下文的后代元素只参与和根元素的对比，不参与和根元素以外的元素对比。_

#### 层叠上下文内部如何排序?(由上到下)⚠️ 只有定位元素才可以比较 z-index

1.z-index 为正值的定位元素。  
2.z-index 为 auto 的定位元素。  
3.未定位的元素。  
4.z-index 为负值的定位元素。  
5.层叠上下文的根元素。

### 移动端 CSS

#### em 与 rem

1em 等于本元素的字体大小。  
1rem 等于根元素的字体大小。  
em 适用于大小跟着字体的变化而变化的属性上，例如 padding,margin,width,height.元素根据继承不同字体的大小，跟着变化。

#### meta 标签

```
<meta name="viewport" content="width=divice-width" initail-scale="1">
```

viewport 是指浏览器看见 web 内容的窗口区域。
width=divice-width 是指浏览器视口的大小要与移动设备的宽度保持一致。  
initail-scale=1 是指初始化比例保持不变（响应式必要要有这个属性）

#### 物理像素/逻辑像素/像素密度？为什么要使用@2x，@3x 这样的图片？

例如 iPhone XS 在写代码的时候，其宽高是 414x896,当给宽度是 414px 时就占个整个屏幕，实际上**物理像素**是 1242x2688，经过计算 1242/414=3，得到的值就是所谓的**像素密度**，1**逻辑像素**=3 物理像素，这就是所谓的三倍屏。  
在三倍屏使用二倍像素的图片就会出现失真，最简单粗暴的方法就是使用最高像素的图片，但影响性能，所有可以使用 css 媒体查询，在不同的像素密度使用不同像素的图片。

#### 一般如何根据设计稿进行移动端的适配？

移动端的适配有两个维度

1. 在不同的像素密度下，使用不同精度的图片。
2. 在不同的屏幕大小下，使用 rem,em,vw,vh 等单位开发。

#### rem 如何计算

1. 看设计图比例，（如设计图是宽 750px，750/100=7.5）,根据比例（7.5）计算出 html 的 fontsize,此时 1rem == 100px  
   document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px'
2. 因为 1vw 等于视口宽的 1/100,（如设计图是宽 750px，1vw == 7.5px,1px == 0.13333333333rem,100px == 13.333333vw）  
   document.documentElement.style.fontSize = 13.333333vw

#### 所有元素设置成百分比，可以实现移动端相应式布局么？

不可以  
因为 width,height,padding,margin 是参考值是块元素而不是屏幕，font-size 的参考值是父元素，border-radius 与 box-shadow 只是部分支持百分比。

#### 如何进行相应式开发

1. 移动端优先，由于移动端窗口小，网速慢，touch 事件等，扩展到 pc 端会较容易一些。
2. 使用媒体查询不同视口调整不同的样式。
3. 使用流式布局，使页面布局随着视口的改变而改变。
4. 使用 viewport，避免浏览器使用虚拟的 veiwport。



### 客户端

#### 性能优化常见考点

浏览器缓存（Brower Caching）是浏览器在**本地磁盘**对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。  
好处有：**减少冗余数据传输、减少服务器负担、加快客户端加载网页的速度**。

浏览器的缓存规则分为两大块：强制缓存和协商缓存。（由 HTTP Response Headers 设置)  
强制缓存：客户端首先在本地检测是否有要请求的数据，如果有直接在本地获取，如果没有向服务端获取。  
协商缓存：客户端在本地获取请求标识，带着这个标识去服务端请求内容，如果请求缓存没有过期，返回 304，在本地获取请求数据，如果过期就在服务端获取请求数据。

强制缓存的实现

```
   Cache-Control:max-age=300(以秒为单位)
```

协商缓存的实现  
Last-Modified:HTTP response headers 中返回 Last-modified 返回头标识了此资源最后在服务端请求的时间。  
Etag：服务端针对这个资源通过算法返回一个唯一的值。

##### 浏览器缓存全过程

1. 浏览器第一次加载资源，返回 200，重服务端获取资源，把资源保存到本地以及 response header.
2. 第二次加载资源，先走强缓存，cache-control 的 max-age 有没有超时，如果没有超时，直接走强制缓存。
3. 没走强缓存，则进行协商缓存，根据 etag 值，判断是否和上次请求一样，如果一样返回 304，如果不一样返回 200，重新加载资源。

##### 缓存保存到哪里？

Service Worker  
Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。  
Memory Cache  
Memory Cache 就是内存缓存，它的效率最快，但是存活时间最短，你一关掉浏览器 Memory Cache 里的文件就被清空了。  
Disk Cache  
Cache 资源被存储在硬盘上，存活时间比 Memory Cache 要持久很多。

##### 说说你所知道的性能优化的方法？

1. 使用 cdn，通过 dns 负载均衡技术请求最近的 chache 服务器，以最快的速度请求服务器内容，也可以放一些静态资源放在 cdn 服务器上。
2. 合理利用缓存，使用 chache-control 与 etag 设置。
3. 使用雪碧图，合并 js 方法，减少请求数量。
4. 合并 css，js，减少请求的体积，服务端可以使用 Gzip 压缩。
5. 使用外联 css 与 js，css 放在头部（浏览器会等 css 加载后在渲染，避免重排，放在尾部会出现白屏），js 放在尾部，减少页面阻塞并发请求，使用代码拆分及延迟加载
6. 频繁操作 demo 时使用 fragment，减少重排。
7. 图片颜色复杂体积大优先使用 jpg，图片小不复杂例如图标优先使用 PNG8，图片颜色复杂半透明效果使用 PNG24.
8. 防抖与节流
9. 使用闭包要适当清理，防止内存泄漏
10. 长列表滚动到可视区域动态加载，图片懒加载。
11. 批量绑定事件，使用事件委托绑定到父节点，利用事件冒泡的机制。

##### 防抖与节流
N秒只执行一次  
**防抖**  
N秒能高频事件再次触发，则重新计算时间    
思路:每次触发取消之前的延时调用  
**节流**
稀释函数的执行频率  
思路:每次触发都判断是否有等待执行的延时函数

#### 什么是 XSS 攻击？如何防止 XSS 攻击？

XSS 是跨站脚本攻击，是 web 应用计算机安全漏洞，通过恶意代码嵌入页面当中。  
防止攻击的方法：

1. 在输入时进行转码，如 html 中<>标签等特殊符号。
2. Cookie 设置 httponly，防止用户通过 document.cookie 获取到 cookie，⚠️ 此 http 头由服务端设置。
3. 重 url 获取值的时候一定要进行格式检查。
4. 不是用 eval 解析运行不确定的数据，json 解析请使用 JSON.parse。
5. 服务端也应该做的关键字的过滤。

#### 什么是CSRF攻击?如何防止CSRF攻击?
CSRF攻击指的是跨站请求伪造攻击,伪造你的身份进行攻击.(攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被
攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。)

防止攻击的方法:  
1. 同源检测的方法
2. Token 来进行验证
3. Cookie 验证的办法
4.  cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用
