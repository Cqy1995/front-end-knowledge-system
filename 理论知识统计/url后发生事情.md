## 从输入URL到浏览器显示页面过程中都发生了什么
1. Url解析
2. DNS查询
3. TCP连接
4. 服务器处理数据
5. 浏览器接收数据
6. 渲染页面
7. js解析执行

1. Url解析
- 查看url是否是合法的url,是否带关键字
- HSTS检查,具备条件会把http转换成https
- 安全检查,网页限制(国内浏览器当时限制996.icu)
- 浏览器缓存的检测,强缓存(exipres/cache-control)与协商缓存(if-Modified-Since/if-None-Match)
2. DNS查询
- 浏览器缓存
- 操作系统的缓存(先在本地查询host文件,在使用内网时会配置host文件)
- 路由器缓存
- ISP/DNS缓存(有次开发我们使用dns,改了点小问题后,没有清理dns缓存,所以没有更新上)
- 根据域名查询
3. TCP连接
**发送端**
- 应用层:发送http请求
- 传输层:TCP传输报文
- 网络层:IP协议查询Mac地址
- 数据链路层:以太网协议
**接受端**
接受端逆向发送的过程
注意:发送端每通过一层增加首部,接受端每通过一层删除首部
4. 服务器处理请求
- 接受TCP报文后,对连接进行处理,对HTTP协议进行解析
- 重定向
- Url重写
5. 浏览器接受响应
- 根据不同状态码与响应资源做不同事情(如:重定向或开启gzip压缩,需要解压等)
6. 渲染页面
- html解析**浏览器解析是从上到下一行一行地解析**
    - 解码:二进制转成字符串,也就是html形式
    - 预解析:提前加载资源,如图片src属性,把请求放入队列中
    - 符号化:词法分析过程,解析成html符号,开始标签,结束标签,属性值,属性名等,识别符号(词法分析前创建document)
    - 构建树:符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点,构建html tree.
    - 容错机制:你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。
    - 事件:浏览器会通过DOMContentLoaded事件来通知DOM解析完成
- css解析
    - css匹配规则:从右到左的顺序,注:尽量用id与class,不要过度层叠.
- 渲染树
    - 计算:让任何尺寸转化成三者(auto/百分比/px)之一,如:rem转化成px.
    - 级联:计算权重
    - 渲染阻塞:css会阻塞js执行,js会阻塞后面的dom解析(css放在js前面,js放在/body前)
- 布局与绘制
    确定渲染树的所有节点属性(位置大小),调用渲染器paint()方法在屏幕显示内容
- 合并渲染层
    把以上绘制合并到一起展示
- 回流与重绘
    - 回流:当几何属性发生变化时,改变位置,需要从html标签开始递归向下,重新计算位置大小.
    - 重绘:除了几何属性(颜色等),需要合并渲染层,重新渲染到屏幕上.
    - 重绘不一定影响回流,回流必需要重绘
7. Javascript编译执行
- 词法分析:js加载完成后,先进入词法分析,分析代码块语法是否正确,抛出错误停止执行.
    - 分词:例如将var a=8,分成var, a, = , 2这样的词法单位
    - 解析:将词法单元转换成机器指令
    - 代码生成:将语法树AST转换成机器指令 
- 预编译:每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前局部执行上下文。
    - 创建执行上下文
        - 创建变量对象:参数,函数,变量
        - 建立作用域链:确认当前执行环境是否能访问变量
        - 确定this指向
    - js执行:js单线程,同步异步与evenloop

